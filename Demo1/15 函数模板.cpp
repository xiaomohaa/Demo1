//#include <iostream>
//
//using std::cout;
//using std::endl;
//
///*	模板
//*	@ 函数模板
//*		> 建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表
//*		> 注意事项
//*			- 自动类型推导，必须推导出一致的数据类型T才可以使用
//*			- 模板必须要确定出T的类型，才可以使用
//*	@ 普通函数与函数模板区别
//*		> 普通函数调用可以发生隐式类型转换
//*		> 函数模板用自动类型推导，不可以发生隐式类型转换
//*		> 函数模板用显示指定类型，可以发生隐式类型转换
//*	@ 普通函数与函数模板的调用规则
//*		> 如果函数模板火绒普通函数都可以实现，优先调用普通函数
//*		> 可以通过空模板参数列表来强制调用函数模板
//*		> 函数模板也可以发生重载
//*		> 如果函数模板可以产生更好的匹配，优先调用函数模板
//*	@ 模板的局限性
//*		> 
//*/
//
//// 函数模板
//
//// 两个整型交换函数
//void swapInt(int& a, int& b)
//{
//	int temp = a;
//	a = b;
//	b = temp;
//}
//
//// 两个浮点型数据交换
//void swapDouble(double& a, double& b)
//{
//	double temp = a;
//	a = b;
//	b = temp;
//}
//
//// 函数模板
//template<typename T>	// 声明一个模板，告诉编译器后面的代码中紧跟着的T不要报错，T是一个通用数据类型
//void mySwap(T& a, T& b)
//{
//	T temp = a;
//	a = b;
//	b = temp;
//}
//
//
//
//void test01(void)
//{
//	int a = 10, b = 20;
//
//	cout << "交换前：" << endl;
//	cout << "a = " << a << endl;
//	cout << "b = " << b << endl;
//	
//	//swapInt(a, b);
//	// 利用函数模板来交换
//	// 两种方式来使用模板
//	
//	// 1、自动类型推导
//	//mySwap(a, b);
//	// 2、显示指定类型
//	mySwap<int>(a, b);
//
//	cout << "交换后：" << endl;
//	cout << "a = " << a << endl;
//	cout << "b = " << b << endl;
//
//}
//
//int main(void)
//{
//	cout << "woCao" << endl;
//
//	test01();
//
//	return 0;
//}